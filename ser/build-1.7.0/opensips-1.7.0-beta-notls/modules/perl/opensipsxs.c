/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2203 from the
 * contents of opensipsxs.xs. Do not edit this file, edit opensipsxs.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "opensipsxs.xs"
/*
 * $Id: opensipsxs.xs 8037 2011-06-22 12:49:07Z razvancrainea $
 *
 * Perl module for OpenSIPS
 *
 * Copyright (C) 2006 Collax GmbH
 *                    (Bastian Friedrich <bastian.friedrich@collax.com>)
 *
 * This file is part of opensips, a free SIP server.
 *
 * opensips is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version
 *
 * opensips is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#include <EXTERN.h>
#include <perl.h>
#include <XSUB.h>
#include <unistd.h>
#undef load_module

/* perl.h defines union semun */
#ifdef USE_SYSV_SEM
# undef _SEM_SEMUN_UNDEFINED
#endif

#include "../../sr_module.h"
#include "../../parser/msg_parser.h"
#include "../../parser/parse_uri.h"
#include "../../usr_avp.h"
#include "../../action.h"
#include "../../flags.h"
#include "../../pvar.h"
#include "../../mem/mem.h"
#include "../../route_struct.h"
#include "../../serialize.h"
#include "../../qvalue.h"
#include "../../dprint.h"

extern int unsafemodfnc;

enum xs_uri_members {
	XS_URI_USER = 0,
	XS_URI_PASSWD,
	XS_URI_HOST,
	XS_URI_PORT,
	XS_URI_PARAMS,
	XS_URI_HEADERS,
	XS_URI_TRANSPORT,
	XS_URI_TTL,
	XS_URI_USER_PARAM,
	XS_URI_MADDR,
	XS_URI_METHOD,
	XS_URI_LR,
	XS_URI_R2,
	XS_URI_TRANSPORT_VAL,
	XS_URI_TTL_VAL,
	XS_URI_USER_PARAM_VAL,
	XS_URI_MADDR_VAL,
	XS_URI_METHOD_VAL,
	XS_URI_LR_VAL,
	XS_URI_R2_VAL
	
	/* These members are no strings:
		unsigned short port_no;
	unsigned short proto; / * from transport * /
	uri_type type; / * uri scheme */
};

/*
 * Return the sip_msg struct referred to by perl reference sv
 */
struct sip_msg * sv2msg(SV *sv) {
	struct sip_msg* m;
	if (SvROK(sv)) {
		sv = SvRV(sv);
		if (SvIOK(sv)) {
			m = INT2PTR(struct sip_msg*, SvIV(sv));
			return m;
		}
	}
	return NULL; /* In case of error above... */
}

struct sip_uri * sv2uri(SV *sv) {
	struct sip_uri* u;
	if (SvROK(sv)) {
		sv = SvRV(sv);
		if (SvIOK(sv)) {
			u = INT2PTR(struct sip_uri*, SvIV(sv));
			return u;
		}
	}
	return NULL; /* In case of error above... */
}

struct action * sv2action(SV *sv) {
	struct action* a;
	if (SvROK(sv)) {
		sv = SvRV(sv);
		if (SvIOK(sv)) {
			a = INT2PTR(struct action*, SvIV(sv));
			return a;
		}
	}
	return NULL; /* In case of error above... */
}

/*
 * We have a private function for two reasons:
 * a) Return SIP_INVALID even if type was sth different
 * b) easy access
 */

inline static int getType(struct sip_msg *msg) {
	int t = SIP_INVALID;

	if (!msg) return SIP_INVALID;

	switch ((msg->first_line).type) {
		case SIP_REQUEST:	t = SIP_REQUEST; break;
		case SIP_REPLY:		t = SIP_REPLY; break;
	}
	return t;
}
		

SV *getStringFromURI(SV *self, enum xs_uri_members what) {
	struct sip_uri *myuri = sv2uri(self);
	str *ret = NULL;

	if (!myuri) {
		LM_ERR("Invalid URI reference\n");
		ret = NULL;
	} else {
		
		switch (what) {
			case XS_URI_USER:	ret = &(myuri->user);
						break;
			case XS_URI_HOST:	ret = &(myuri->host);
						break;
			case XS_URI_PASSWD:	ret = &(myuri->passwd);
						break;
			case XS_URI_PORT:	ret = &(myuri->port);
						break;
			case XS_URI_PARAMS:	ret = &(myuri->params);
						break;
			case XS_URI_HEADERS:	ret = &(myuri->headers);
						break;
			case XS_URI_TRANSPORT:	ret = &(myuri->transport);
						break;
			case XS_URI_TTL:		ret = &(myuri->ttl);
						break;
			case XS_URI_USER_PARAM:	ret = &(myuri->user_param);
						break;
			case XS_URI_MADDR:	ret = &(myuri->maddr);
						break;
			case XS_URI_METHOD:	ret = &(myuri->method);
						break;
			case XS_URI_LR:		ret = &(myuri->lr);
						break;
			case XS_URI_R2:		ret = &(myuri->r2);
						break;
			case XS_URI_TRANSPORT_VAL:	ret = &(myuri->transport_val);
						break;
			case XS_URI_TTL_VAL:	ret = &(myuri->ttl_val);
						break;
			case XS_URI_USER_PARAM_VAL:	ret = &(myuri->user_param_val);
						break;
			case XS_URI_MADDR_VAL:	ret = &(myuri->maddr_val);
						break;
			case XS_URI_METHOD_VAL:	ret = &(myuri->method_val);
						break;
			case XS_URI_LR_VAL:	ret = &(myuri->lr_val);
						break;
			case XS_URI_R2_VAL:	ret = &(myuri->r2_val);
						break;

			default:	LM_INFO("Unknown URI element"
						" requested: %d\n", what);
					break;
		}
	}

	if ((ret) && (ret->len)) {
		return sv_2mortal(newSVpv(ret->s, ret->len));
	} else {
		return &PL_sv_undef;
	}
}



/*
 * Calls an exported function. Parameters are copied and fixup'd.
 *
 * Return codes:
 *   -1 - Function not available (or other error).
 *    1 - Function was called. Its return value is returned via the retval
 *        parameter.
 */

int moduleFunc(struct sip_msg *m, char *func,
	       char *param1, char *param2,
	       int *retval) {

	cmd_export_t *exp_func_struct;
	struct action *act;
	char *argv[2];
	int argc = 0;
	action_elem_t elems[MAX_ACTION_ELEMS];

	if (!func) {
		LM_ERR("moduleFunc called with null function name. Error.");
		return -1;
	}

	if ((!param1) && param2) {
		LM_ERR("moduleFunc called with parameter 1 UNSET and"
			   " parameter 2 SET. Error.");
		return -1;
	}


	if (param1) {
		argv[0] = (char *)pkg_malloc(strlen(param1)+1);
		strcpy(argv[0], param1);
		argc++;
	} else {
		argv[0] = NULL;
	}

	if (param2) {
		argv[1] = (char *)pkg_malloc(strlen(param2)+1);
		strcpy(argv[1], param2);
		argc++;
	} else {
		argv[1] = NULL;
	}

	exp_func_struct = find_cmd_export_t(func, argc, 0);
	if (!exp_func_struct) {
		LM_ERR("function '%s' called, but not available.", func);
		*retval = -1;
		if (argv[0]) pkg_free(argv[0]);
		if (argv[1]) pkg_free(argv[1]);
		return -1;
	}

	elems[0].type = CMD_ST;
	elems[0].u.data = exp_func_struct;
	elems[1].type = STRING_ST;
	elems[1].u.data = argv[0];
	elems[2].type = STRING_ST;
	elems[2].u.data = argv[1];
	act = mk_action(	MODULE_T,
				3,
				elems,
				0);


	if (!act) {
		LM_ERR("action structure could not be created. Error.");
		if (argv[0]) pkg_free(argv[0]);
		if (argv[1]) pkg_free(argv[1]);
		return -1;
	}


	if (exp_func_struct->fixup) {
		if (!unsafemodfnc) {
			LM_ERR("Module function '%s' is unsafe. Call is refused.\n", func);
			if (argv[0]) pkg_free(argv[0]);
			if (argv[1]) pkg_free(argv[1]);
			*retval = -1;
			return -1;
		}

		if (argc>=2) {
			*retval = exp_func_struct->fixup(&(act->elem[2].u.data), 2);
			if (*retval < 0) {
				LM_ERR("Error in fixup (2)\n");
				return -1;
			}
			act->elem[2].type = MODFIXUP_ST;
		}
		if (argc>=1) {
			*retval = exp_func_struct->fixup(&(act->elem[1].u.data), 1);
			if (*retval < 0) {
				LM_ERR("Error in fixup (1)\n");
				return -1;
			}
			act->elem[1].type = MODFIXUP_ST;
		}
		if (argc==0) {
			*retval = exp_func_struct->fixup(0, 0);
			if (*retval < 0) {
				LM_ERR("Error in fixup (0)\n");
				return -1;
			}
		}
	}

	*retval = do_action(act, m);

	if ((act->elem[2].type == MODFIXUP_ST) && (act->elem[2].u.data)) {
		/* pkg_free(act->elem[2].u.data); */
		LM_WARN("moduleFunction: A fixup function was called. "
				"This currently creates a memory leak.\n");
	}

	if ((act->elem[1].type == MODFIXUP_ST) && (act->elem[1].u.data)) {
		/* pkg_free(act->elem[1].u.data); */
		LM_WARN("moduleFunction: A fixup function was called. "
				"This currently creates a memory leak.\n");
	}

	if (argv[0]) pkg_free(argv[0]);
	if (argv[1]) pkg_free(argv[1]);

	pkg_free(act);
	
	return 1;
}


/**
 * Rewrite Request-URI
 */
static inline int rewrite_ruri(struct sip_msg* _m, char* _s)
{
	struct action act;

	act.type = SET_URI_T;
	act.elem[0].type = STR_ST;
	act.elem[0].u.s.s = _s;
	act.elem[0].u.s.len = strlen(_s);
	act.next = 0;
	
	if (do_action(&act, _m) < 0)
	{
		LM_ERR("rewrite_ruri: Error in do_action\n");
		return -1;
	}
	return 0;
}


/**
 * Compile a string with pseudo variables substituted by their values.
 * A string buffer is allocated. Deallocate afterwards!
 */
char *pv_sprintf(struct sip_msg *m, char *fmt) {
	int buf_size = 4096;
	pv_elem_t *model;
	str s;
	char *out = (char *)pkg_malloc(buf_size);
	char *ret = NULL;

	if (!out) {
		LM_ERR("pv_sprintf: Memory exhausted!\n");
		return NULL;
	}

	s.s = fmt; s.len = strlen(s.s);
	if(pv_parse_format(&s, &model) < 0) {
		LM_ERR("pv_sprintf: ERROR: wrong format[%s]!\n",
			fmt);
		return NULL;
	}

	if(pv_printf(m, model, out, &buf_size) < 0) {
		ret = NULL;
	} else {
		ret = strdup(out);
	}

	pv_elem_free_all(model);
	pkg_free(out);

	return ret;
}

/**
 * Convert an SV to an int_str struct. Needed in AVP package.
 * - val: SV to convert.
 * - is: pointer to resulting int_str
 * - flags: pointer to flags to set
 * - strflag: flag mask to be or-applied for string match
 */

inline int sv2int_str(SV *val, int_str *is,
		      unsigned short *flags, unsigned short strflag) {
	char *s;
	STRLEN len;

	if (!SvOK(val)) {
		LM_ERR("AVP:sv2int_str: Invalid value "
			"(not a scalar).\n");
		return 0;
	}
	
	if (SvIOK(val)) { /* numerical name */
		is->n = SvIV(val);
		*flags = 0;
		return 1;
	} else if (SvPOK(val)) {
		s = SvPV(val, len);
		is->s.len = len;
		is->s.s = s;
		(*flags) |= strflag;
		return 1;
	} else {
		LM_ERR("AVP:sv2int_str: Invalid value "
			"(neither string nor integer).\n");
		return 0;
	}
}

/* ************************************************************************ */
/* Object methods begin here */

#if 0
  "Skipped embedded POD."
#endif
#line 441 "opensipsxs.xs"

#line 449 "opensipsxs.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 501 "opensipsxs.c"

XS(XS_OpenSIPS_log); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS_log)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "level, log");
    {
	int	level = (int)SvIV(ST(0));
	char *	log = (char *)SvPV_nolen(ST(1));
#line 471 "opensipsxs.xs"
#line 517 "opensipsxs.c"
#line 472 "opensipsxs.xs"
#line 519 "opensipsxs.c"
#line 473 "opensipsxs.xs"
	switch (level) {
	case L_ALERT:	LM_ALERT("%s", log); break;
	case L_CRIT:	LM_CRIT("%s", log); break;
	case L_ERR:	LM_ERR("%s", log); break;
	case L_WARN:	LM_WARN("%s", log); break;
	case L_NOTICE:	LM_NOTICE("%s", log); break;
	case L_INFO:	LM_INFO("%s", log); break;
	default:	LM_DBG("%s", log); break;
	}
#line 530 "opensipsxs.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_OpenSIPS__Message_getType); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_getType)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
#line 509 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
#line 550 "opensipsxs.c"
	int	RETVAL;
	dXSTARG;
#line 511 "opensipsxs.xs"
#line 554 "opensipsxs.c"
#line 512 "opensipsxs.xs"
  	RETVAL = getType(msg);
#line 557 "opensipsxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_getStatus); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_getStatus)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
#line 529 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
    str *ret;
#line 579 "opensipsxs.c"
	SV *	RETVAL;
#line 532 "opensipsxs.xs"
#line 582 "opensipsxs.c"
#line 533 "opensipsxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		if (getType(msg) != SIP_REPLY) {
			LM_ERR("getStatus: Status not available in"
				" non-reply messages.");
			ST(0) = &PL_sv_undef;
		} else {
			ret = &((msg->first_line).u.reply.status);
			ST(0) = sv_2mortal(newSVpv(ret->s, ret->len));
		}
	}
#line 597 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_getReason); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_getReason)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
#line 559 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
    str *ret;
#line 618 "opensipsxs.c"
	SV *	RETVAL;
#line 562 "opensipsxs.xs"
#line 621 "opensipsxs.c"
#line 563 "opensipsxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		if (getType(msg) != SIP_REPLY) {
			LM_ERR("getReason: Reason not available in"
				" non-reply messages.");
			ST(0) = &PL_sv_undef;
		} else {
			ret = &((msg->first_line).u.reply.reason);
			ST(0) = sv_2mortal(newSVpv(ret->s, ret->len));
		}
	}
#line 636 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_getVersion); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_getVersion)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
#line 588 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
    str *ret;
#line 657 "opensipsxs.c"
	SV *	RETVAL;
#line 591 "opensipsxs.xs"
#line 660 "opensipsxs.c"
#line 592 "opensipsxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		if (getType(msg) == SIP_REQUEST) {
			ret = &((msg->first_line).u.request.version);
		} else { /* SIP_REPLY */
			ret = &((msg->first_line).u.reply.version);
		}
		ST(0) = sv_2mortal(newSVpv(ret->s, ret->len));
	}
#line 673 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_getRURI); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_getRURI)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
#line 622 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
    str *ret;
#line 694 "opensipsxs.c"
	SV *	RETVAL;
#line 625 "opensipsxs.xs"
#line 697 "opensipsxs.c"
#line 626 "opensipsxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		if (getType(msg) != SIP_REQUEST) {
			LM_ERR("Not a request message - "
				"no RURI available.\n");
			ST(0) = &PL_sv_undef;
		} else {
			ret = &((msg->first_line).u.request.uri);
			ST(0) = sv_2mortal(newSVpv(ret->s, ret->len));
		}
	}
#line 712 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_getMethod); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_getMethod)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
#line 655 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
    str *ret;
#line 733 "opensipsxs.c"
	char *	RETVAL;
	dXSTARG;
#line 658 "opensipsxs.xs"
#line 737 "opensipsxs.c"
#line 659 "opensipsxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		if (getType(msg) != SIP_REQUEST) {
			LM_ERR("Not a request message - "
				"no method available.\n");
			ST(0) = &PL_sv_undef;
		} else {
			ret = &((msg->first_line).u.request.method);
			ST(0) = sv_2mortal(newSVpv(ret->s, ret->len));
		}
	}
#line 752 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_getFullHeader); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_getFullHeader)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
#line 688 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
    char *firsttoken;
    long headerlen;
#line 774 "opensipsxs.c"
	SV *	RETVAL;
#line 692 "opensipsxs.xs"
#line 777 "opensipsxs.c"
#line 693 "opensipsxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		if (getType(msg) == SIP_INVALID) {
			LM_ERR("getFullHeader: Invalid message type.\n");
			ST(0)  = &PL_sv_undef;
		} else {
			parse_headers(msg, ~0, 0);
			if (getType(msg) == SIP_REQUEST) {
				firsttoken = (msg->first_line).u.request.method.s;
			} else { /* SIP_REPLY */
				firsttoken = (msg->first_line).u.reply.version.s;
			}

			if (msg->eoh == NULL)
				headerlen = 0;
			else
				headerlen = ((long)(msg->eoh))
						-((long)(firsttoken));

			if (headerlen > 0) {
				ST(0) = 
				    sv_2mortal(newSVpv(firsttoken, headerlen));
			} else {
				ST(0) = &PL_sv_undef;
			}
		}
	}
#line 808 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_getBody); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_getBody)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
#line 734 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
#line 828 "opensipsxs.c"
	SV *	RETVAL;
#line 736 "opensipsxs.xs"
#line 831 "opensipsxs.c"
#line 737 "opensipsxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		parse_headers(msg, ~0, 0);
		ST(0) = sv_2mortal(newSVpv(get_body(msg), 0));
	}
#line 840 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_getMessage); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_getMessage)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
#line 756 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
#line 860 "opensipsxs.c"
	SV *	RETVAL;
#line 758 "opensipsxs.xs"
#line 863 "opensipsxs.c"
#line 759 "opensipsxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		ST(0) = sv_2mortal(newSVpv(msg->buf, 0));
	}
#line 871 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_getHeader); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_getHeader)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	self = ST(0);
	char *	name = (char *)SvPV_nolen(ST(1));
#line 782 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
    str *body = NULL;
    struct hdr_field *hf;
    int found = 0;
    int namelen = strlen(name);
#line 898 "opensipsxs.c"
	SV *	RETVAL;
#line 788 "opensipsxs.xs"
#line 901 "opensipsxs.c"
#line 789 "opensipsxs.xs"
	LM_DBG("searching '%s'\n", name);

	if (!msg) {
		LM_ERR("Invalid message reference\n");
	} else {
		parse_headers(msg, ~0, 0);
		for (hf = msg->headers; hf; hf = hf->next) {
			if (namelen == hf->name.len) {
				if (strncmp(name, hf->name.s, namelen) == 0) {
					/* Found the right header. */
					found = 1;
					body = &(hf->body);
					XPUSHs(sv_2mortal(newSVpv(body->s,
								  body->len)));
				}
			}
		}
	}
	if (!found) {
		XPUSHs(&PL_sv_undef);
	}
#line 924 "opensipsxs.c"
	PUTBACK;
	return;
    }
}


XS(XS_OpenSIPS__Message_getHeaderNames); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_getHeaderNames)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	self = ST(0);
#line 823 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
    struct hdr_field *hf = NULL;
    int found = 0;
#line 949 "opensipsxs.c"
	AV *	RETVAL;
#line 828 "opensipsxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
	} else {
		parse_headers(msg, ~0, 0);
		for (hf = msg->headers; hf; hf = hf->next) {
			found = 1;
			XPUSHs(sv_2mortal(newSVpv(hf->name.s, hf->name.len)));
		}
	}
	if (!found) {
		XPUSHs(&PL_sv_undef);
	}
#line 964 "opensipsxs.c"
	PUTBACK;
	return;
    }
}


XS(XS_OpenSIPS__Message_moduleFunction); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_moduleFunction)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "self, func, string1 = NULL, string2 = NULL");
    {
	SV *	self = ST(0);
	char *	func = (char *)SvPV_nolen(ST(1));
	char *	string1;
	char *	string2;
#line 968 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
    int retval; /* Return value of called function */
    int ret;    /* Return value of moduleFunc - < 0 for "non existing function" and other errors */
#line 990 "opensipsxs.c"
	int	RETVAL;
	dXSTARG;

	if (items < 3)
	    string1 = NULL;
	else {
	    string1 = (char *)SvPV_nolen(ST(2));
	}

	if (items < 4)
	    string2 = NULL;
	else {
	    string2 = (char *)SvPV_nolen(ST(3));
	}
#line 972 "opensipsxs.xs"
#line 1006 "opensipsxs.c"
#line 973 "opensipsxs.xs"
	LM_DBG("Calling exported func '%s', Param1 is '%s',"
		" Param2 is '%s'\n", func, string1, string2);

	ret = moduleFunc(msg, func, string1, string2, &retval);
	if (ret < 0) {
		LM_ERR("calling module function '%s' failed."
			" Missing loadmodule?\n", func);
		retval = -1;
	}
	RETVAL = retval;
#line 1018 "opensipsxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_log); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_log)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "self, level, log");
    {
	SV *	self = ST(0);
	int	level = (int)SvIV(ST(1));
	char *	log = (char *)SvPV_nolen(ST(2));
#line 1012 "opensipsxs.xs"
#line 1040 "opensipsxs.c"
#line 1013 "opensipsxs.xs"
#line 1042 "opensipsxs.c"
#line 1014 "opensipsxs.xs"
	switch (level) {
	case L_ALERT:	LM_ALERT("%s", log); break;
	case L_CRIT:	LM_CRIT("%s", log); break;
	case L_ERR:	LM_ERR("%s", log); break;
	case L_WARN:	LM_WARN("%s", log); break;
	case L_NOTICE:	LM_NOTICE("%s", log); break;
	case L_INFO:	LM_INFO("%s", log); break;
	default:	LM_DBG("%s", log); break;
	}
#line 1053 "opensipsxs.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_OpenSIPS__Message_rewrite_ruri); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_rewrite_ruri)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, newruri");
    {
	SV *	self = ST(0);
	char *	newruri = (char *)SvPV_nolen(ST(1));
#line 1042 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
#line 1074 "opensipsxs.c"
	int	RETVAL;
	dXSTARG;
#line 1044 "opensipsxs.xs"
#line 1078 "opensipsxs.c"
#line 1045 "opensipsxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		RETVAL = -1;
	} else {
		if (getType(msg) != SIP_REQUEST) {
			LM_ERR("Not a Request. RURI rewrite unavailable.\n");
			RETVAL = -1;
		} else {
			LM_DBG("New R-URI is [%s]\n", newruri);
			RETVAL = rewrite_ruri(msg, newruri);
		}
	}
#line 1092 "opensipsxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_setFlag); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_setFlag)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, flag");
    {
	SV *	self = ST(0);
	unsigned int	flag = (unsigned int)SvUV(ST(1));
#line 1074 "opensipsxs.xs"
	struct sip_msg *msg = sv2msg(self);
#line 1114 "opensipsxs.c"
	int	RETVAL;
	dXSTARG;
#line 1076 "opensipsxs.xs"
#line 1118 "opensipsxs.c"
#line 1077 "opensipsxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		RETVAL = -1;
	} else {
		RETVAL = setflag(msg, flag);
	}
#line 1126 "opensipsxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_resetFlag); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_resetFlag)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, flag");
    {
	SV *	self = ST(0);
	unsigned int	flag = (unsigned int)SvUV(ST(1));
#line 1098 "opensipsxs.xs"
	struct sip_msg *msg = sv2msg(self);
#line 1148 "opensipsxs.c"
	int	RETVAL;
	dXSTARG;
#line 1100 "opensipsxs.xs"
#line 1152 "opensipsxs.c"
#line 1101 "opensipsxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		RETVAL = -1;
	} else {
		RETVAL = resetflag(msg, flag);
	}
#line 1160 "opensipsxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_isFlagSet); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_isFlagSet)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, flag");
    {
	SV *	self = ST(0);
	unsigned int	flag = (unsigned int)SvUV(ST(1));
#line 1121 "opensipsxs.xs"
	struct sip_msg *msg = sv2msg(self);
#line 1182 "opensipsxs.c"
	int	RETVAL;
	dXSTARG;
#line 1123 "opensipsxs.xs"
#line 1186 "opensipsxs.c"
#line 1124 "opensipsxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		RETVAL = -1;
	} else {
		RETVAL = isflagset(msg, flag) == 1 ? 1 : 0;
	}
#line 1194 "opensipsxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_pseudoVar); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_pseudoVar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, varstring");
    {
	SV *	self = ST(0);
	char *	varstring = (char *)SvPV_nolen(ST(1));
#line 1148 "opensipsxs.xs"
	struct sip_msg *msg = sv2msg(self);
	char *ret;
#line 1217 "opensipsxs.c"
	SV *	RETVAL;
#line 1151 "opensipsxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = &PL_sv_undef;
	} else {
		ret = pv_sprintf(msg, varstring);
		if (ret) {
			ST(0) = sv_2mortal(newSVpv(ret, strlen(ret)));
			free(ret);
		} else {
			ST(0) = &PL_sv_undef;
		}
	}
#line 1232 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_append_branch); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_append_branch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "self, branch = NULL, qval = NULL");
    {
	SV *	self = ST(0);
	char *	branch;
	char *	qval;
#line 1178 "opensipsxs.xs"
	struct sip_msg *msg = sv2msg(self);
	action_elem_t elems[MAX_ACTION_ELEMS];
	qvalue_t q;
	int err = 0;
	struct action *act = NULL;
#line 1258 "opensipsxs.c"
	int	RETVAL;
	dXSTARG;

	if (items < 2)
	    branch = NULL;
	else {
	    branch = (char *)SvPV_nolen(ST(1));
	}

	if (items < 3)
	    qval = NULL;
	else {
	    qval = (char *)SvPV_nolen(ST(2));
	}
#line 1184 "opensipsxs.xs"
#line 1274 "opensipsxs.c"
#line 1185 "opensipsxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		RETVAL = -1;
	} else {
		if (qval) {
			if (str2q(&q, qval, strlen(qval)) < 0) {
				LM_ERR("append_branch: Bad q value.");
			} else { /* branch and qval set */
				elems[0].type = STR_ST;
				elems[0].u.data = branch;
				elems[1].type = NUMBER_ST;
				elems[1].u.data = (void *)(long)q;
				act = mk_action(APPEND_BRANCH_T,
						2,
						elems,
						0);
			}
		} else {
			if (branch) { /* branch set, qval unset */
				elems[0].type = STR_ST;
				elems[0].u.data = branch;
				elems[1].type = NUMBER_ST;
				elems[1].u.data = (void *)Q_UNSPECIFIED;
				act = mk_action(APPEND_BRANCH_T,
						2,
						elems,
						0);
			} else { /* neither branch nor qval set */
				elems[0].type = STR_ST;
				elems[0].u.data = NULL;
				elems[1].type = NUMBER_ST;
				elems[1].u.data = (void *)Q_UNSPECIFIED;
				act = mk_action(APPEND_BRANCH_T,
						2,
						elems,
						0);
			}
		}

		if (act) {
			RETVAL = do_action(act, msg);
		} else {
			RETVAL = -1;
		}
	}
#line 1321 "opensipsxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_serialize_branches); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_serialize_branches)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, clean_before");
    {
	SV *	self = ST(0);
	int	clean_before = (int)SvIV(ST(1));
#line 1245 "opensipsxs.xs"
	struct sip_msg *msg = sv2msg(self);
#line 1343 "opensipsxs.c"
	int	RETVAL;
	dXSTARG;
#line 1247 "opensipsxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		RETVAL = -1;
	} else {
		RETVAL = serialize_branches(msg, clean_before);
	}
#line 1353 "opensipsxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_next_branches); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_next_branches)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
#line 1268 "opensipsxs.xs"
	struct sip_msg *msg = sv2msg(self);
#line 1374 "opensipsxs.c"
	int	RETVAL;
	dXSTARG;
#line 1270 "opensipsxs.xs"
  	if (!msg) {
		LM_ERR("Invalid message reference\n");
		RETVAL = -1;
	} else {
		RETVAL = next_branches(msg);
	}
#line 1384 "opensipsxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__Message_getParsedRURI); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__Message_getParsedRURI)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
#line 1292 "opensipsxs.xs"
    struct sip_msg *msg = sv2msg(self);
    struct sip_uri *uri;
    SV *ret;
#line 1407 "opensipsxs.c"
	SV *	RETVAL;
#line 1296 "opensipsxs.xs"
#line 1410 "opensipsxs.c"
#line 1297 "opensipsxs.xs"
	if (!msg) {
		LM_ERR("Invalid message reference\n");
		ST(0) = NULL;
	} else {
		parse_sip_msg_uri(msg);
		parse_headers(msg, ~0, 0);

		uri = &(msg->parsed_uri);
		ret = sv_newmortal();
		sv_setref_pv(ret, "OpenSIPS::URI", (void *)uri);
		SvREADONLY_on(SvRV(ret));

		ST(0) = ret;
	}
#line 1426 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_user); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_user)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1335 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_USER);
#line 1447 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_host); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_host)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1348 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_HOST);
#line 1468 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_passwd); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_passwd)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1361 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_PASSWD);
#line 1489 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_port); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_port)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1374 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_PORT);
#line 1510 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_params); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_params)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1387 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_PARAMS);
#line 1531 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_headers); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_headers)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1400 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_HEADERS);
#line 1552 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_transport); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_transport)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1413 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_TRANSPORT);
#line 1573 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_ttl); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_ttl)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1426 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_TTL);
#line 1594 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_user_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_user_param)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1439 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_USER_PARAM);
#line 1615 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_maddr); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_maddr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1453 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_MADDR);
#line 1636 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1465 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_METHOD);
#line 1657 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_lr); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_lr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1478 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_LR);
#line 1678 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_r2); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_r2)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1491 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_R2);
#line 1699 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_transport_val); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_transport_val)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1504 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_TRANSPORT_VAL);
#line 1720 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_ttl_val); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_ttl_val)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1517 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_TTL_VAL);
#line 1741 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_user_param_val); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_user_param_val)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1530 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_USER_PARAM_VAL);
#line 1762 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_maddr_val); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_maddr_val)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1543 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_MADDR_VAL);
#line 1783 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_method_val); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_method_val)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1556 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_METHOD_VAL);
#line 1804 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_lr_val); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_lr_val)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1569 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_LR_VAL);
#line 1825 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__URI_r2_val); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__URI_r2_val)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 1582 "opensipsxs.xs"
	ST(0) = getStringFromURI(self, XS_URI_R2_VAL);
#line 1846 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__AVP_add); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__AVP_add)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "p_name, p_val");
    {
	SV *	p_name = ST(0);
	SV *	p_val = ST(1);
#line 1626 "opensipsxs.xs"
	int_str name;
	int_str val;
	unsigned short flags = 0;
	char *s;
	STRLEN len;
#line 1871 "opensipsxs.c"
	int	RETVAL;
	dXSTARG;
#line 1632 "opensipsxs.xs"
  	RETVAL = 0;
	if (SvOK(p_name) && SvOK(p_val)) {
		if (!sv2int_str(p_name, &name, &flags, AVP_NAME_STR)) {
			RETVAL = -1;
		} else if (!sv2int_str(p_val, &val, &flags, AVP_VAL_STR)) {
			RETVAL = -1;
		}

		if (RETVAL == 0) {
			if (flags & AVP_NAME_STR) {
				name.n = get_avp_id(&name.s);
			}
			RETVAL = add_avp(flags, name.n, val);
		}
	}
#line 1890 "opensipsxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__AVP_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__AVP_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "p_name");
    {
	SV *	p_name = ST(0);
#line 1666 "opensipsxs.xs"
	struct usr_avp *first_avp;
	int_str name;
	int_str val;
	unsigned short flags = 0;
	SV *ret = &PL_sv_undef;
	int err = 0;
	char *s;
	STRLEN len;
#line 1918 "opensipsxs.c"
	int	RETVAL;
	dXSTARG;
#line 1675 "opensipsxs.xs"
	if (SvOK(p_name)) {
		if (!sv2int_str(p_name, &name, &flags, AVP_NAME_STR)) {
			LM_ERR("AVP:get: Invalid name.");
			err = 1;
		}
	} else {
		LM_ERR("AVP:get: Invalid name.");
		err = 1;
	}

	if (err == 0) {
		if (flags & AVP_NAME_STR) {
			name.n = get_avp_id(&name.s);
		}
		first_avp = search_first_avp(flags, name.n, &val, NULL);

		if (first_avp != NULL) { /* found correct AVP */
			if (is_avp_str_val(first_avp)) {
				ret = sv_2mortal(newSVpv(val.s.s, val.s.len));
			} else {
				ret = sv_2mortal(newSViv(val.n));
			}
		} else {
			/* Empty AVP requested. */
		}
	}

	ST(0) = ret;
#line 1950 "opensipsxs.c"
    }
    XSRETURN(1);
}


XS(XS_OpenSIPS__AVP_destroy); /* prototype to pass -Wmissing-prototypes */
XS(XS_OpenSIPS__AVP_destroy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "p_name");
    {
	SV *	p_name = ST(0);
#line 1720 "opensipsxs.xs"
	struct usr_avp *first_avp;
	int_str name;
	int_str val;
	unsigned short flags = 0;
	SV *ret = &PL_sv_undef;
	char *s;
	STRLEN len;
#line 1976 "opensipsxs.c"
	int	RETVAL;
	dXSTARG;
#line 1728 "opensipsxs.xs"
	RETVAL = 1;
	if (SvOK(p_name)) {
		if (!sv2int_str(p_name, &name, &flags, AVP_NAME_STR)) {
			RETVAL = 0;
			LM_ERR("AVP:destroy: Invalid name.");
		}
	} else {
		RETVAL = 0;
		LM_ERR("VP:destroy: Invalid name.");
	}

	if (RETVAL == 1) {
		if (flags & AVP_NAME_STR) {
			name.n = get_avp_id(&name.s);
		}
		first_avp = search_first_avp(flags, name.n, &val, NULL);

		if (first_avp != NULL) { /* found correct AVP */
			destroy_avp(first_avp);
		} else {
			RETVAL = 0;
			/* Empty AVP requested. */
		}
	}

#line 2005 "opensipsxs.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_OpenSIPS); /* prototype to pass -Wmissing-prototypes */
XS(boot_OpenSIPS)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("OpenSIPS::log", XS_OpenSIPS_log, file);
        (void)newXSproto_portable("OpenSIPS::Message::getType", XS_OpenSIPS__Message_getType, file, "$");
        (void)newXSproto_portable("OpenSIPS::Message::getStatus", XS_OpenSIPS__Message_getStatus, file, "$");
        (void)newXSproto_portable("OpenSIPS::Message::getReason", XS_OpenSIPS__Message_getReason, file, "$");
        (void)newXSproto_portable("OpenSIPS::Message::getVersion", XS_OpenSIPS__Message_getVersion, file, "$");
        (void)newXSproto_portable("OpenSIPS::Message::getRURI", XS_OpenSIPS__Message_getRURI, file, "$");
        (void)newXSproto_portable("OpenSIPS::Message::getMethod", XS_OpenSIPS__Message_getMethod, file, "$");
        (void)newXSproto_portable("OpenSIPS::Message::getFullHeader", XS_OpenSIPS__Message_getFullHeader, file, "$");
        (void)newXSproto_portable("OpenSIPS::Message::getBody", XS_OpenSIPS__Message_getBody, file, "$");
        (void)newXSproto_portable("OpenSIPS::Message::getMessage", XS_OpenSIPS__Message_getMessage, file, "$");
        (void)newXSproto_portable("OpenSIPS::Message::getHeader", XS_OpenSIPS__Message_getHeader, file, "$$");
        (void)newXSproto_portable("OpenSIPS::Message::getHeaderNames", XS_OpenSIPS__Message_getHeaderNames, file, "$");
        (void)newXSproto_portable("OpenSIPS::Message::moduleFunction", XS_OpenSIPS__Message_moduleFunction, file, "$$;$$");
        (void)newXSproto_portable("OpenSIPS::Message::log", XS_OpenSIPS__Message_log, file, "$$$");
        (void)newXSproto_portable("OpenSIPS::Message::rewrite_ruri", XS_OpenSIPS__Message_rewrite_ruri, file, "$$");
        (void)newXSproto_portable("OpenSIPS::Message::setFlag", XS_OpenSIPS__Message_setFlag, file, "$$");
        (void)newXSproto_portable("OpenSIPS::Message::resetFlag", XS_OpenSIPS__Message_resetFlag, file, "$$");
        (void)newXSproto_portable("OpenSIPS::Message::isFlagSet", XS_OpenSIPS__Message_isFlagSet, file, "$$");
        (void)newXSproto_portable("OpenSIPS::Message::pseudoVar", XS_OpenSIPS__Message_pseudoVar, file, "$$");
        (void)newXSproto_portable("OpenSIPS::Message::append_branch", XS_OpenSIPS__Message_append_branch, file, "$;$$");
        (void)newXSproto_portable("OpenSIPS::Message::serialize_branches", XS_OpenSIPS__Message_serialize_branches, file, "$$");
        (void)newXSproto_portable("OpenSIPS::Message::next_branches", XS_OpenSIPS__Message_next_branches, file, "$");
        (void)newXSproto_portable("OpenSIPS::Message::getParsedRURI", XS_OpenSIPS__Message_getParsedRURI, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::user", XS_OpenSIPS__URI_user, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::host", XS_OpenSIPS__URI_host, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::passwd", XS_OpenSIPS__URI_passwd, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::port", XS_OpenSIPS__URI_port, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::params", XS_OpenSIPS__URI_params, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::headers", XS_OpenSIPS__URI_headers, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::transport", XS_OpenSIPS__URI_transport, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::ttl", XS_OpenSIPS__URI_ttl, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::user_param", XS_OpenSIPS__URI_user_param, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::maddr", XS_OpenSIPS__URI_maddr, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::method", XS_OpenSIPS__URI_method, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::lr", XS_OpenSIPS__URI_lr, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::r2", XS_OpenSIPS__URI_r2, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::transport_val", XS_OpenSIPS__URI_transport_val, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::ttl_val", XS_OpenSIPS__URI_ttl_val, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::user_param_val", XS_OpenSIPS__URI_user_param_val, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::maddr_val", XS_OpenSIPS__URI_maddr_val, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::method_val", XS_OpenSIPS__URI_method_val, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::lr_val", XS_OpenSIPS__URI_lr_val, file, "$");
        (void)newXSproto_portable("OpenSIPS::URI::r2_val", XS_OpenSIPS__URI_r2_val, file, "$");
        (void)newXSproto_portable("OpenSIPS::AVP::add", XS_OpenSIPS__AVP_add, file, "$$");
        (void)newXSproto_portable("OpenSIPS::AVP::get", XS_OpenSIPS__AVP_get, file, "$");
        (void)newXSproto_portable("OpenSIPS::AVP::destroy", XS_OpenSIPS__AVP_destroy, file, "$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

